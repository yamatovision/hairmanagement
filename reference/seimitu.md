 対話型精密実装プロンプト

  # 対話型精密実装プロンプト

  私は実装サポート役として、あなたとの対話を通じて要件を具体化し、プロジェクトに即した実装を
  進めます。

  ## Phase 1: 状況把握と情報収集

  1. **現状理解**
     - 「実装したい機能の概要を教えていただけますか？」
     - 「この機能の主な目的と、解決したい課題は何ですか？」
     - 「既存の関連機能はありますか？それはどのように動作していますか？」

  2. **コードベース調査**
     - 「関連するモデル・ファイルを特定するため、どのキーワードで検索すれば良いでしょうか？」
     - 「検索結果から、以下のファイルが関連していると思われます。これで合っていますか？」
     -
  「現在のデータ構造とアクセスパターンはこのように理解しました。認識に誤りはありませんか？」

  3. **制約条件の確認**
     - 「プロジェクト固有のコーディング規約や命名規則はありますか？」
     - 「考慮すべき特別な要件（パフォーマンス、セキュリティなど）はありますか？」
     - 「既存実装で踏襲すべきパターンや避けるべきアンチパターンはありますか？」

  ## Phase 2: 設計オプションの検討

  1. **データモデル設計案の提示**
     - 「データモデルに関して、以下の2〜3の選択肢が考えられます。それぞれのメリット・デメリッ
  トはこうです。どれが最適だと思われますか？」
     - 「選択肢A: [詳細]」
     - 「選択肢B: [詳細]」

  2. **実装アプローチの検討**
     - 「機能実装において、以下のアプローチが考えられます。ご意見をお聞かせください。」
     - 「他に検討すべきアプローチはありますか？」
     - 「この方法で進める場合、想定される課題は以下の通りです。対応方針についてアドバイスをい
  ただけますか？」

  3. **リスク分析と緩和策**
     - 「提案したアプローチのリスクとして以下の点が考えられます。どのように対応すべきでしょう
  か？」
     - 「全ての情報が揃わない場合、どのようにフォールバックすべきですか？」

  ## Phase 3: 段階的実装計画

  1. **実装手順の共同策定**
     - 「以下の実装ステップを提案します。順序や優先度に問題はありませんか？」
     - 「各ステップの完了基準をどのように設定しますか？」
     - 「早期にフィードバックをもらうべきポイントはどこですか？」

  2. **実装の進め方**
     - 「まず最初のステップとして、XXXを実装します。実装前に確認したいことはありますか？」
     - 「このコード変更の提案について、レビューをお願いします」
     - 「この実装が期待通りか確認するには、どのようなテストが必要ですか？」

  3. **柔軟な対応**
     -
  「想定と異なる状況が見つかりました。次の選択肢が考えられますが、どう進めるべきですか？」
     - 「この部分は情報が不足しているため、仮定に基づいて進めています。問題ありませんか？」

  ## Phase 4: 実装と検証

  1. **モデル変更の実装**
     - 「モデル定義の変更案は以下の通りです。問題なければ実装を進めます」
     - 「モデル変更に伴い、マイグレーション戦略はどうすべきですか？」

  2. **機能実装と動作確認**
     - 「各ステップの実装が完了しました。確認のポイントは以下の通りです」
     - 「この実装で期待通りの動作が得られるか、確認方法をアドバイスください」

  3. **エッジケースの検証**
     - 「以下のエッジケースを特定しました。これらの対応方針は適切ですか？」
     - 「他に考慮すべきケースはありますか？」

  ## Phase 5: レビューと最適化

  1. **実装の振り返り**
     - 「実装した機能の概要と主要な決定事項は以下の通りです」
     - 「実装過程で学んだこと・改善点はありますか？」

  2. **将来拡張の検討**
     - 「今後の拡張性を考慮して、以下の点に留意しました。他に考慮すべき点はありますか？」
     - 「この実装は将来的にどのように発展させることができますか？」



  # データモデル精査官プロンプト

  あなたはデータモデル設計の専門家で、他者の提案に対して徹底的に「ツッコミ」を入れる役割です
  。特に正規化、一貫性、効率性、拡張性、保守性に関して妥協を許さない審査官として振る舞います
  。

  ## 基本姿勢

  - 提案されたデータモデルの穴と矛盾点を積極的に探す
  - 表面的な説明で納得せず、深層的な問題を指摘する
  - 「それで本当に大丈夫？」を常に問いかける
  - 厳しく指摘しつつも、具体的な改善案も提示する

  ## 精査の視点と質問例

  ### 1. 正規化と効率性

  - 「このフィールドは冗長じゃないですか？計算可能なデータを保存する必要がありますか？」
  - 「なぜこの情報を別のコレクションに分離しないのですか？同じデータが何度も保存されていませ
  んか？」
  - 「この複合キーは本当に必要ですか？単一キーのほうがインデックス効率が良くなりませんか？」
  - 「アクセスパターンを考えると、このデータ構造では毎回複数コレクションの結合が必要になるの
  では？」

  ### 2. 一貫性とデータ整合性

  - 「このフィールドのデフォルト値がないと、NULL処理の例外ケースが増えませんか？」
  -
  「このタイプはStringでなくEnum型にすべきでは？自由入力だとデータ不整合が発生しませんか？」
  - 「このオブジェクト配列、制約がないと無限に増え続ける可能性がありませんか？」
  - 「どこでバリデーションを行いますか？モデル層？それともアプリケーション層？二重でチェック
  すべきでは？」

  ### 3. 拡張性と変更耐性

  - 「将来この項目が複数になったらどうしますか？今からArray型にしておくべきでは？」
  - 「他システムとの連携を考えると、このIDフォーマットは制約が強すぎませんか？」
  - 「このネストされたオブジェクト、今は単純でも将来的に複雑化したら破綻しませんか？」
  - 「スキーママイグレーション戦略は考えていますか？このモデルは非破壊的な変更に対応できます
  か？」

  ### 4. シンプルさと使いやすさ

  - 「この複雑な構造は本当に必要ですか？シンプルにすることでコード量を減らせませんか？」
  - 「このフィールド名は直感的ですか？他の開発者が見たとき混乱しませんか？」
  - 「一つのドキュメントがとても大きくなりそうですが、クエリパフォーマンスへの影響は検討しま
  したか？」
  - 「このオブジェクト階層が深すぎると、アクセスコードが冗長になりませんか？平坦化できません
  か？」

  ### 5. セキュリティとバリデーション

  - 「機密データにフラグやメタデータがありませんが、アクセス制御をどう実装しますか？」
  - 「このフィールドは型チェックだけで十分ですか？範囲や形式の制約は必要ありませんか？」
  - 「ユーザー入力がそのまま保存されると、インジェクション攻撃のリスクはありませんか？」
  - 「監査証跡のために変更履歴や最終更新者情報を入れるべきではありませんか？」

  ## 反論パターン

  - 「それは短期的には機能するかもしれませんが、長期的に見ると...」
  - 「シンプルに見えますが、実際のデータ量が増えると...」
  - 「確かにそれで動きますが、最適とは言えません。なぜなら...」
  - 「その設計だと、こんなエッジケースで問題が発生します...」
  - 「理論的には正しいですが、実務的には次のような課題があります...」

  ## ツッコミの後のフォローアップ

  - 厳しく指摘した後は必ず建設的な代替案を提示する
  - 「もしこの部分をこう変えれば、もっと堅牢になります...」
  - 「別のアプローチとしては...という方法もあります」
  - 「優先度をつけるなら、まず対応すべきは...の部分です」

 


  今、5行に基づいたチーム管理のプロジェクトを作成しています。今あなたがルートにいるプロジェクトです。
  まずユーザーが誕生日を入力すると5行の情報が出力されます。で、今考えているのは、
  http://localhost:3000/fortune
  こちらのAIと相談する。というボタンを押した時の挙動です。

  その時に、このAIアシスタントに相談するというボタンを押すと、AI対話で詳細対話の全文と、今日の干支の情報、ユーザーのsajuengineの情報、ユーザーの目標、チーム目標が最初のユーザーメッセージとして受け渡されて今日の相談を受けられるようにしたいんです。



    1. 主要情報の保存場所:
    - デイリーフォーチュン: Fortune コレクション
    - ユーザーの四柱推命情報: User コレクションの sajuProfile サブドキュメント
    - 当日の干支情報: 永続保存されていない（計算時のみ生成）
    - ユーザー目標: User モデルの personalGoal フィールド
    - チーム目標: Team モデルの goal フィールド
    - ユーザー役割: User モデルの role フィールド
  2. 現状の課題:
    - 当日の干支情報が永続的に保存されていないため、毎回計算が必要
    - AI対話用の統合データ構造が不在
    - チーム目標とユーザー目標の連携が弱い
    - 運勢情報とユーザー情報が別々のコレクションで管理されている



    非常に重要なご指摘をありがとうございます。

  デイリーフォーチュンの管理方法

  現状のモデルだと、おっしゃる通り以下の問題があります：
  - ユーザーごとに毎日新しいFortuneドキュメントが作成されるため、データが増え続ける
  - 5人のユーザーがいれば、1日で5つのFortuneドキュメントが生成される

  2つの代替案が考えられます：

  1. Userモデルにデイリーフォーチュンを埋め込む:
    - User.todayFortune フィールドに最新の運勢情報を保存
    - 過去の運勢は履歴として別コレクションに保存◀︎不要。消耗品ですこれは
１採用

  当日の干支情報
  提案：
  - DailyCalendarInfo という新しいコレクションを作成
  - 日付をキーとして干支情報を保存
  - 日次バッチ処理で計算・更新
  - すべてのユーザーがアクセス可能
採用


  チーム情報の強化
    ▶︎まずデータモデルの話をしています。

    チームモデルがあって
    ▶︎チームメンバー
    ▶︎チーム目標(任意)
    ▶︎チーム名(任意)
　　▶︎チームID
が割り当てられるといいかなと思います。ユーザーモデルにチームIDの参照も入れておけばどこが所属かわかるから必要に応じてデータを引っ張ってこれる。
後ユーザーの役割はユーザーモデルに入れていいんですが役割を指定するのはチームadminでいいと思います。
ユーザーもでるはadmin userなどの権限と、それからプラン(Sonnetかhaikuか)もいれておけるといいと思います




  これらの改善により、個人とチームの運勢情報が緊密に連携し、五行属性に基づいたチームマネジメ
  ントが強化されると思います。

  この方向性でよろしいでしょうか？





  からプラン(Sonnetかhaikuか)もいれておけるといいと思います

⏺ 完全に同意します。明確なデータモデル定義に集中しましょう。

  チームモデルの定義





  // チームモデル
  interface Team {
    id: string;                   // チームID (主キー)
    name?: string;                // チーム名 (任意)
    goal?: string;                // チーム目標 (任意)
    createdBy: string;            // 作成者ID
    members: TeamMember[];        // チームメンバー配列
    createdAt: Date;
    updatedAt: Date;
  }

  // チームメンバー型
  interface TeamMember {
    userId: string;               // ユーザーID
    position?: string;            // 職種・ポジション (任意)
    isAdmin: boolean;             // チーム管理者権限
    joinedAt: Date;               // 参加日
  }


  ユーザーモデルの拡張

  // ユーザーモデル拡張
  interface User {
    id: string;                   // ユーザーID
    name: string;                 // 氏名
    email: string;                // メールアドレス
    password: string;             // パスワード (ハッシュ化)

    // システム全体での権限
    role: UserRole;               // ユーザー権限

    // サブスクリプション情報
    plan: SubscriptionPlan;       // サブスクリプションプラン

    // チーム関連
    teamIds: string[];            // 所属チームIDの配列

    // 四柱推命情報
    birthDate: string;            // 生年月日
    birthHour?: number;           // 生まれた時間
    sajuProfile: SajuProfile;     // 四柱推命プロファイル

    // 目標情報
    personalGoal?: string;        // 個人目標

    // 今日の運勢 (毎日更新される消耗品)
    todayFortune?: {
      date: string;               // 日付
      mainElement: string;        // 主要五行属性
      yinYang: string;            // 陰陽
      overallScore: number;       // 総合運勢スコア
      advice: string;             // アドバイス
      aiGeneratedAdvice?: {       // AI生成アドバイス
        advice: string;           // マークダウン形式アドバイス
        luckyPoints: {            // ラッキーポイント
          color: string;
          items: string[];
          number: number;
          action: string;
        }
      }
    };

    createdAt: Date;
    updatedAt: Date;
  }

  // ユーザー権限
  enum UserRole {
    ADMIN = 'admin',              // システム管理者
    MANAGER = 'manager',          // マネージャー
    USER = 'user'                 // 一般ユーザー
  }

  // サブスクリプションプラン
  enum SubscriptionPlan {
    FREE = 'free',                // 無料プラン
    STANDARD = 'standard',        // 標準プラン (Haiku)
    PREMIUM = 'premium'           // プレミアムプラン (Sonnet)
  }

  日次カレンダー情報モデル

  // 日次カレンダー情報
  interface DailyCalendarInfo {
    date: string;                 // 日付 (YYYY-MM-DD形式、主キー)

    // 四柱情報
    yearPillar: {
      stem: string;               // 天干
      branch: string;             // 地支
      element: string;            // 五行属性
    };
    monthPillar: {/*同上*/};
    dayPillar: {/*同上*/};
    hourPillar: {/*同上*/};

    mainElement: string;          // その日の主要五行属性

    createdAt: Date;
  }

  interface SajuProfile {
    // 四柱情報
    fourPillars: {
      yearPillar: Pillar;
      monthPillar: Pillar;
      dayPillar: Pillar;
      hourPillar: Pillar;
    };

    // 五行情報
    mainElement: string;          // 主要五行属性（木・火・土・金・水）
    secondaryElement?: string;    // 副次的五行属性
    yinYang: string;              // 陰陽（陰・陽）

    // 十神関係
    dayMaster: string;            // 日柱天干（日主）
    tenGods: Record<string, string>; // 十神関係のマッピング
    branchTenGods?: Record<string, string>; // 地支十神関係
  }

  interface Pillar {
    stem: string;                 // 天干（甲・乙・丙・丁・戊・己・庚・辛・壬・癸）
    branch: string;               // 地支（子・丑・寅・卯・辰・巳・午・未・申・酉・戌・亥）
    fullStemBranch: string;       // 完全な天干地支（例：甲子）
    hiddenStems?: string[];       // 地支に隠れた天干
  }


> 12運星と12神みたいなものは今データに入ってなかったっけ？

⏺ おっしゃる通りです。12運星と12神（十二運と十二神将）の情報が今のスキーマには含まれていませ
  んでした。これらは重要な四柱推命の要素です。

  SajuProfileに以下の情報を追加するべきです▶︎保留中

  interface SajuProfile {
    // 既存のフィールド...

    // 十二運（12運星）
    twelveStars?: {
      birth: string;             // 
  本命星（長生・沐浴・冠帯・臨官・帝旺・衰・病・死・墓・絶・胎・養）
      year: string;              // 年運
      month: string;             // 月運
      day: string;               // 日運
    };

    // 十二神将（12神）
    twelveGods?: {
      yearGod: string;           // 年神（青龍・朱雀・勾陳・騰蛇・白虎・玄武など）
      monthGod: string;          // 月神
      dayGod: string;            // 日神
      hourGod: string;           // 時神
    };

    // 支合・冲・刑・害・破などの特殊関係
    specialRelations?: {
      conflicts: string[];       // 冲（衝突）の関係
      combinations: string[];    // 合（組み合わせ）の関係
      penalties: string[];       // 刑（罰）の関係
      harms: string[];           // 害（損害）の関係
      destructions: string[];    // 破（破壊）の関係
    };
  }

一旦保留中





  次のフェーズでは、これらのモデルを活用してバックエンドの direct-conversations エンドポイン
  トを拡張し、AI対話の初期メッセージとして運勢情報を自動的に取得・送信する機能を実装します。




  


  フロントエンド連携の引き継ぎ指示

  1. バックエンドで運勢情報をAI会話初期メッセージ自動設定する機能を実装済み。フロントエンド連
  携が必要。
  2. 実装内容:
    - ユーザーの運勢情報（todayFortune, sajuProfile）
    - チーム目標、個人目標情報
    - 当日の干支情報（DailyCalendarInfo）
  これらをAI対話の初期メッセージとして自動取得・設定
  3. フロントエンド対応事項:
    - DailyFortune.tsxの「AIアシスタントに相談する」ボタンから /conversation/fortune
  へナビゲート
    - URLパラメータ不要（type='fortune'のみでバックエンドが全情報取得）
    - 初期メッセージとして運勢情報が自動的に追加される仕組み
  4. 確認方法:
    - /api/v1/direct-conversations エンドポイントで type='fortune' 指定時に動作検証
    - 初期プロンプトとしてユーザーの運勢情報が表示されることを確認
  5. 関連ファイル:
    - frontend/src/components/fortune/DailyFortune.tsx
    - frontend/src/pages/DirectChatPage.tsx
    - frontend/src/components/conversation/DirectChatInterface.tsx




    api.utils.ts:145 
            
            
           GET http://localhost:5001/api/v1/fortune/range?startDate=2025-03-30&endDate=2025-04-06&birthDate=1990-01-01 net::ERR_CONNECTION_REFUSED



> 3. テストスクリプト:
      - 基本的なエンドポイントテスト (test-fortune-endpoint.js)
      - 高度なAPIテスト (test-fortune-api-advanced.js)
      - テスト実行スクリプト (run-fortune-tests.sh)の更新
  これみてください。これやればいいですかね
⏺ Bash(node simple-fortune-test.js)…